
docker ps     --> To see the current active containers
docker ps -a  --> To see the all containers which are already deleted.
docker images --> To see the all images
docker ps -q --> gives only running container ids
docker ps -aq --> gives all container ids
docker images -q --> gives images ids
docker rm <container> ---> to delete container
docker rm $(docker ps -aq) --> to delete all containers existing
docker rmi <image> --> to delete image
docker rmi $(docker images -q) --> to delete all images
docker run -itd --name web-app -p 8080:8000 <image_name> ---> Runs the container in discrete(back ground) with name web-app and open port 8080 on host side
                                                              and 8000 and container side so we can access caontainer application at port 8080.
docker build -f /path/to/Dockerfile -t hello-hi . ---> Buils the image from docker taken from -f docker file path by giving -t tags for images generally 
                                                       hub username/repo name:current_version and . tells build the to use current dir to take files.
docker run -itd -e abc=def <image_name> ---> -e is Setting the environment variables for the container.
docker run -itd -e abc <image_name> --> if a env variable already exists in our machine.
docker run -d --env /path/to/env_file <image> --> when a multiple envs present in a file we can pass file using --env.
docker inspect <cont_name> ---> we can check all the details regarding container including the env variables.




Docker installation on EC2 ubuntu

sudo apt update --> update new applications from internet
sudo apt install docker.io -y --> Installs docker 
sudo systemctl status docker --> To check the status of docker
docker run hello-world --> To verify docker is available or not
sudo usermod -aG docker ubuntu --> Docker needs admin permissions to run

Docker Build
--> Converts the docker file to docker image.
    -> docker build -t nihanth/hello_app:latest .
       -> -t is tag
       -> nihanth is username for dockerhub
       -> hello_app is repo name is docker hub
       -> latest is the tag name(generally it will be versions)
       -> . Checks for dockerfile in current dir and coverts it into image
    -> docker build -f /path/to/folder -t nihanth/hello_app:v1 .
        -> -f is where we can give the path to dockerfile

Docker Run
--> Converts the docker image to docker container, the container will be created when we use this command and automatically deletes when cmds are runned in docker file.
    -> docker run -it nihanth/hello_app:latest
       -> -it is a iteractive terminal where we can go to container and can run cmds
    -> docker create <image_name>
       -> This will only create container from image.
    -> docker start <conatiner_id>
       -> Starts the container
    -> docker run -it <image_id> tail -f /dev/null
       -> Runs the container but doesn't exit

Docker Registry
--> Registry is like a github where we can push and pull images from docker hub.
    -> docker login
       -> Login in to the docker hub
    -> docker push username/reponame:tag
       -> This will push the image to docker hub
    -> docker pull uname/reponame:tag
       -> pulls the image from docker hub

Docker Networking
    --> Bridge networking is default networking for docker
 To check the networks
    -> Docker network ls
 To create own network
    -> docker network create -d bridge <bridge_name>
 To attach bridge network to new container
    -> docker run -d --net=<bridge_name> --name <container_name> <image_name>
         docker run -d --net=new_bridge --name nginx_container nginx:latest
 To login into container
    -> docker exec -it <container_name> /bin/bash
         docker exec -it nginx_container /bin/bash ---> /bin/bash: loads up the bash
 To inscept(gives all details about the container even ip address of container>
    -> docker inspect <container_name>
         docker inscept nginx_container



----------------------------------------------------------------------
Networking_Example_project

Create an EC2 instance.
Create a new bridge network (custom Docker bridge network).
Create three containers:
    login
    logout
    finance
Attach the existing default bridge network to:
    login container
    logout container
Attach the new custom bridge network to:
    finance container
Inspect the logout container and note down its IP address.
Exec (SSH) into the login container and test connectivity:
    Ping the logout container → packets are received (same network).
    Ping the finance container → packets are not received (different network).
Attach another container to the host network.
When inspecting the container, you will not see a separate container IP, because:
It uses the host network mode, meaning it shares the host machine’s network stack and IP address.

----------------------------------------------------------------------
Docker Bind Mounts

 Create a bind mount
   - Create a file in host and add some data:
       mkdir src1
       cd src1
       echo "Msg from host" > shared.txt

   - Mount it to a container:
       docker run -it \
         --mount type=bind,source=$(pwd)/src1,target=/app \
         ubuntu \
         /bin/bash

     → We run the container interactively with the Ubuntu image.
     → We launch /bin/bash so the container does not exit immediately.
     → The folder /app inside the container is directly linked to src1 on the host.

Docker Volumes
  Create Volume
    docker volume create <volume_name> :- volume will be stored in /var/lib/docker/volumes/<volume_name>/_data in host
  List of Volumes
    docker volume ls
  To create container and attach Volume to a container
    docker run -it --mount type=volume,source=<volume_name>,target=/app --name <container_name> <image_name>
----------------------------------------------------------------------
Docker File 1

FROM ubuntu:latest --> Need an base image here we are using ubuntu os
WORKDIR /app --> Creates app folder in a container and run the files in it.
COPY . /app --> copies the current dir into app folder
RUN apt-get update && apt-get install -y python3 python3-pip --> Run the dependencies and install required.
ENV NAME World --> sets env variables NAME=World
CMD["python3","app.py"] --> Runs the app.py file with python3

----------------------------------------------------------------------

Docker File 2 (check the files here https://github.com/Nihanth-NS/Docker-Zero-to-Hero/tree/main/examples/python-web-app)
  NOTE ::: THIS DOCKER FILE WILL NOT ABLE TO CREATE IMAGE BEACUSE UBUNTU IS NOT ALLOWING EXTERNAL INSTALLATIONS
FROM ubuntu
WORKDIR /app
COPY requriments.txt /app/ --> copying req.txt file to the container
COPY devops /app/  --> copying devops file which contains entire python code(django) to the container
RUN apt-get update &&/
    apt-get install -y python3 python3-pip &&/
    pip install -r requriments.txt &&/  --> -r read from file
    cd devops
ENTRYPOINT ["python3"] --> Entry point is where it will run default where we can't override it (default : python3 manage.py runserver 0.0.0.0:8000) 
CMD ["manage.py","runserver","0.0.0.0:8000"]

---> Here we are running django application by 
      ---> docker run -p 8000:8000 <image id> (default : python3 manage.py runserver 0.0.0.0:8000)
           -p is where we need to open port <host port:app port> by giving this we can access the application 
              from outside else the application only runs inside container and we can't access it.
      ---> docker run -p 8000:8000 <image id> app.py runserver 0.0.0.0:8000
            Here we are overriding the cmds, instead of manage.py we are using app.py


----------------------------------------------------------------------
Docker File 3 (check the files here https://github.com/Nihanth-NS/Docker-Zero-to-Hero/tree/main/examples/python-web-app)

FROM ubuntu
WORKDIR /app
COPY requriments.txt /app/
COPY devops /app/
RUN apt-get update && apt-get install -y python3 python3-pip python3-venv 
SHELL ["/bin/bash","-c"] ----> by default linux uses /bin/sh which is not support for source cmd so we are switching to /bin/bash
RUN python3 -m venv venv1 &&/ ---> creating virtual environment with name venv1
    source venv1/bin/activate &&/ ---> activating the venv1 with source cmd
    pip install -no-cache-dir -r requriments.txt ---> Installing reqs in the venv1 and close it
EXPOSE 8000 ---> Expose tells that we are using 8000 port it will not open any port.
CMD source venv1/bin/activate && python3 manage.py runserver 0.0.0.0:8000 ----> here we are activating the VM and running the manage.py

----> This is same as above docker application i.e. we are running django application here by installing python 
      and creating virtual environment(venv) and installing all requriments there
